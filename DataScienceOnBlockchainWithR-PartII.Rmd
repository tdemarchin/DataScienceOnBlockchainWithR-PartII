---
title: "Data Science on Blockchain with R. Part II: Tracking the NFT transactions"
author: "By Thomas de Marchin (Senior Manager Statistics and Data Sciences at Pharmalex) and Milana Filatenkova (Manager Statistics and Data Sciences at Pharmalex)"
date: "XXX2021"
output: html_document
---

```{r setup, include=FALSE}
rm(list=ls())
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
```

![Image from Alina Grubnyak on Unsplash.](figures/photo-1545987796-200677ee1011.jpg)

# Introduction

```{r}
# First, let's load a few useful packages
library(tidyverse)
library(httr)
library(jsonlite)
library(plotly)
library(patchwork)
library(cowplot)
library(network)
library(ggraph)
library(networkDynamic)
library(ndtv)
```


How to make the blockchain more transparent? Money laundering,... I don't want to have any problem with the mafia so let's focus on something else (NFT) at the moment.



The Weird Whales project is a collection of 3350 whales which have been programmatically generated from an ocean of combinations, each with unique characteristics and different traits: https://weirdwhalesnft.com/. This was created by 12-year-old programmer named Benyamin Ahmed. The 3,350 computer-generated “Weird Whales” almost instantly sold out based on the heartwarming story and Benyamin made more than 150,000\$. Whales were initially sold at approximately 60\$ but since then, there price has been multiplied by 100...  Read this for the whole story: https://www.cnbc.com/amp/2021/08/25/12-year-old-coder-made-6-figures-selling-weird-whales-nfts.html?__twitter_impression=true

```{r, fig.cap=c("Examples of Weird Whale NFTs. These NFTs (token ids 525, 564, 645, 1523, 2968, 1109, 618 and 816) belong to the creator of the collection Benyamin Ahmed (Benoni) who gave us the permission to use them in this article.")}

p1 <- ggdraw() + draw_image("figures/WeirdWhales/525.png", scale = 0.9) 
p2 <- ggdraw() + draw_image("figures/WeirdWhales/564.png", scale = 0.9)
p3 <- ggdraw() + draw_image("figures/WeirdWhales/645.png", scale = 0.9)
p4 <- ggdraw() + draw_image("figures/WeirdWhales/1523.png", scale = 0.9)
p5 <- ggdraw() + draw_image("figures/WeirdWhales/2968.png", scale = 0.9)
p6 <- ggdraw() + draw_image("figures/WeirdWhales/1109.png", scale = 0.9)
p7 <- ggdraw() + draw_image("figures/WeirdWhales/618.png", scale = 0.9)
p8 <- ggdraw() + draw_image("figures/WeirdWhales/816.png", scale = 0.9)
p1 + p2 + p3 + p4 + p5 +p6 + p7 + p8 + plot_layout(nrow = 2)
```


# Extracting the data

This section is about downloading the sales data, as well sale prices. It is very interesting but also a bit technical so if you are only interested by the analysis, you can skip this section.

## Transfers

Code of the Weird Whales contract: https://etherscan.io/address/0x96ed81c7f4406eff359e27bff6325dc3c9e042bd#code
To make it easier to extract information from the blockchain (which can be fairly complicated due to how the information is stored on the blockchain), we can read the events. In Solidity, events are dispatched signals the smart contracts can fire. Any app connected to Ethereum network can listen to these events and act accordingly. Here is a list of recent Weird Whales event: https://etherscan.io/address/0x96ed81c7f4406eff359e27bff6325dc3c9e042bd#events

We are particularly interested by the event Transfer. Every time a transfer of NFT will take place, an event will be stored on the blockchain with that structure: Transfer (index_topic_1 address from, index_topic_2 address to, index_topic_3 uint256 tokenId)
Describe...

We will therefore extract all transfer events related to Weird Whales. For this, we can filter on the hash signature of this event (also called Topic 0). If you look on Etherscan (https://etherscan.io/tx/0xa677cfc3b4084f7a5f2e5db5344720bb2ca2c0fe8f29c26b2324ad8c8d6c2ba3#eventlog), you will see that topic 0 for this event is "0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef".

Here is an example of a Weird Whale NFT transaction: https://etherscan.io/tx/0x2b21165a60abe3dfdc94d03fd9daa0671dc9b982e8b7fdf6342ed28967c15cfd#eventlog

Here we outline a process to create a databases containing trade data of the Weird Whales.


```{r}
# EtherScan requires a token, have a look at their website. Please, use your own token!
EtherScanAPIToken <- "UJP16VCE9D29XFAA86RWADATJ5K4PBSYD9" 

dataWeirdWhaleTransfer <- list()
continue <- 1
i <- 0

while(continue == 1){ # We will run trough the blocks (from the earliest mentioning Weird whales to the latest). As soon ...
i <- i + 1
if(i == 1){fromBlock = 12857046} #first block mentioning Weird Whale contract

# Get the transfer events from the Weird Whale contract
resWeirdWhaleTransfer <- GET("https://api.etherscan.io/api",
          query = list(module="logs", 
                       action="getLogs", 
                       fromBlock=fromBlock, #first block mentioning Weird Whale contract
                       toBlock="latest",
                       address="0x96ed81c7f4406eff359e27bff6325dc3c9e042bd", # address of the Weird Whale contract
                       topic0="0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef", # hash of the Transfer event
                       apikey=EtherScanAPIToken)) 

dataWeirdWhaleTransfer[[i]] <- fromJSON(rawToChar(resWeirdWhaleTransfer$content), flatten=TRUE)$result %>%
  select(-gasPrice, -gasUsed, -logIndex)

if(i > 1){
if(all_equal(dataWeirdWhaleTransfer[[i]], dataWeirdWhaleTransfer[[i-1]]) == TRUE){continue <- 0}  
} #at some point, we always download the same last transaction

fromBlock <- max(as.numeric(dataWeirdWhaleTransfer[[i]]$blockNumber)) # increase the block to start looking at for the next iteration
}

dataWeirdWhaleTransfer <- bind_rows(dataWeirdWhaleTransfer) %>% #coerce list to dataframe
  distinct() # eliminate potential duplicated rows due to our trick to avoid the 1000 transaction limitation from EtherScan

# Do a bit of data management
dataWeirdWhaleTransfer <- dataWeirdWhaleTransfer %>% 
  mutate(timeStamp=as.POSIXct(as.numeric(timeStamp), origin="1970-01-01")) %>%
  mutate(topics = purrr::map(topics, setNames, c("eventHash","fromAddress","toAddress","tokenId"))) %>% # it is important to set the names otherwise unnest_wider will print many warning messages.
  unnest_wider(topics) %>% # reshape the topic column (list) to get a column for each topic. 
  mutate(tokenId=as.character(as.numeric(tokenId)), # convert Hexadecmal to numeric
         blockNumber=as.numeric(blockNumber),
         fromAddress=paste0("0x", str_sub(fromAddress,-40,-1)), # reshape the adress format to something more conventional
         toAddress=paste0("0x", str_sub(toAddress,-40,-1))) %>%
  mutate(tokenId = factor(tokenId, levels=as.character(sort(unique(as.numeric(tokenId))))))
```

## Sales price

While both the transfer and the sale can be managed by the same contract, it is a bit different on OpenSea. The sale is managed by the *OpenSea* contract and if it it approved (asked price reached), the contract call the *Weird whale* contract which then triggers the transfer. So if we want to know the price at which the NFTs were sold (in addition to the transfer above), we need to extract data from another contract. 

```{r}
# Get the OrderMatch events from the Weird Whale contract
resOpenSeaOrderMatch <- GET("https://api.etherscan.io/api",
          query = list(module="logs",
                       action="getLogs",
                       fromBlock="12859414", # before that block, transfer event was for minting
                       toBlock="latest",
                       address="0x7be8076f4ea4a4ad08075c2508e481d6c946d12b", # adress of the Open Sea contract
                       topic0="0xc4109843e0b7d514e4c093114b863f8e7d8d9a458c372cd51bfe526b588006c9", # hash of the OrderMatch event
                       sort="desc",
                       apikey=EtherScanAPIToken))

dataOpenSeaOrderMatch <- fromJSON(rawToChar(resOpenSeaOrderMatch$content), flatten=TRUE)$result %>%
  select(-gasPrice, -gasUsed, -logIndex)

dataOpenSeaOrderMatch <- dataOpenSeaOrderMatch %>%
  mutate(timeStamp=as.POSIXct(as.numeric(timeStamp), origin="1970-01-01")) %>%
  mutate(topics = purrr::map(topics, setNames, c("eventHash","fromAddress","toAddress","metadata"))) %>%
  unnest_wider(topics) %>% # reshape the topic column (list) to get a column for each topics
  mutate(blockNumber=as.numeric(blockNumber),
         fromAddress=paste0("0x", str_sub(fromAddress,-40,-1)), # reshape the adress format to something more conventional
         toAddress=paste0("0x", str_sub(toAddress,-40,-1))) 

# if you look at the call to the contract, the price is encoded in uint256 type in the data field. It is preceded by two others objects, buyHash and sellHash, both in bytes32 types. The uint256 and bytes32 types are both 32 bytes long, which makes 64 Hexadecimal characters. We thus have to take the last 64 characters and convert them to decimal to get the price.
dataOpenSeaOrderMatch <- dataOpenSeaOrderMatch %>%
  mutate(price = str_sub(data, start = -64), 
         price = as.numeric(paste0("0x", price)),
         price = price / 10^18) # This is expressed in Wei, the smallest denomination of ether. 1 ether = 1,000,000,000,000,000,000 Wei (10\^18).

dataWeirdWhaleFull <- right_join(dataWeirdWhaleTransfer, dataOpenSeaOrderMatch, by="transactionHash")
```



# Summary statistics


1) Faire un Graph du prix des transactions en fonction du temps. (genre barplot - histogram)

We have data from
```{r}
# Summary statistics
summary(dataWeirdWhaleTransfer$timeStamp)

dataWeirdWhaleTransfer %>%
  summarise(`Number of transactions` = n(),
            `Unique token` = length(unique(tokenId)),
            `Unique senders` = length(unique(fromAddress)),
            `Unique receivers` = length(unique(toAddress)),
            `Date range` = paste(min(timeStamp), max(timeStamp), sep=" - "),
            `Days` = max(timeStamp) - min(timeStamp)
            ) 

summarySender <- dataWeirdWhaleTransfer %>%
  group_by(fromAddress) %>%
  summarise(`Number of transactions`=n()) %>%
  rename(`Sender address` = fromAddress) %>%
  arrange(desc(`Number of transactions`))

tokenIdFilter <- dataWeirdWhaleTransfer %>%
  group_by(tokenId) %>%
  summarise(n = n()) %>%
  filter(n>3)

dataWeirdWhaleTransferFiltered <- dataWeirdWhaleTransfer %>%
  filter(tokenId %in% tokenIdFilter$tokenId) %>%
  droplevels()
```



# Visualizing the network

A vertex (or node) of a graph is one of the objects that are connected together. The connections between the vertices are called edges (or links). 
There are several packages available on R to plot network, the most known being *network* and *igraph*. I have a preferences for the former as it gives the possibility to create interactive plot via the *networkDynamic* package. We will first create a simple network and plot it using the *ggraph* package. Although it is possible to plot the network using the base plot functionalities of the *network* package, *ggraph* makes it easier by using the *ggplot2* framework.

```{r, fig}
tokenIdFilter <- dataWeirdWhaleTransfer %>%
  group_by(tokenId) %>%
  summarise(n = n()) %>%
  filter(n>7)

dataWeirdWhaleTransferFiltered <- dataWeirdWhaleTransfer %>%
  filter(tokenId %in% tokenIdFilter$tokenId) %>%
  droplevels()

dataWeirdWhaleTransferFiltered <- dataWeirdWhaleTransferFiltered %>%
  mutate(timeStampHour = round.POSIXt(timeStamp, "hour")) %>% # The time resolution is seconds. That is nice but it leads to a lot of computation (frames) for our network. Let's round to hours.
  mutate(timeStampHourNumeric = as.numeric(timeStampHour)/3600) %>%
  mutate(timeStampHourNumeric = timeStampHourNumeric-min(timeStampHourNumeric))  

# vertices is a listing of all the addresses involved in the transactions   
vertices <- tibble(label = unique(c(dataWeirdWhaleTransferFiltered$fromAddress,
                                           dataWeirdWhaleTransferFiltered$toAddress))) %>%
  rowid_to_column("id") %>% # instead of using the addresses to visually identify the vertices, we will use shorter ID numbers 
  mutate(onset = 0, terminus = max(dataWeirdWhaleTransferFiltered$timeStampHourNumeric))

# edges is a listing of the transactions
edges <- dataWeirdWhaleTransferFiltered %>%
  left_join(vertices, by = c("fromAddress" = "label")) %>% 
  rename(from = id) %>%
  left_join(vertices, by = c("toAddress" = "label")) %>%
  rename(to = id) 

# This will be useful to create a temporal dynamic network later on. Edges will appear at `onset` and disappear at `terminus.`
edges <- edges %>%
  rename(onset = timeStampHourNumeric) %>% 
  mutate(terminus = max(onset), #  
         tokenId = as.character(tokenId)) %>%
  select(from, to, onset, terminus, tokenId) 

# create the network using network
network <- network(edges,  
                  vertex.attr = vertices, 
                   matrix.type="edgelist", 
                loops=T, 
                multiple=T, 
                ignore.eval = F)

pNetwork <- ggraph(network) + 
  geom_edge_fan(aes(color = tokenId), arrow = arrow(length = unit(6, "pt"), type = "open")) +
    geom_node_point(color = "black", size = 4) +
   theme_void() +
  geom_node_text(aes(label = id), color = "gold", size = 2, fontface = "bold") 
pNetwork

# create a dynamic temporal network
dNetwork <- networkDynamic(edge.spells = as.data.frame(edges[,c("onset", "terminus", "from", "to", "tokenId")]),
                           vertex.spells = as.data.frame(vertices[,c("onset", "terminus", "id", "label")]),
                           create.TEAs = TRUE)

# plot(network)
compute.animation(dNetwork, 
                   animation.mode='MDSJ',
                  # animation.mode='Graphviz', # Graphviz is the best
                  slice.par=list(interval = 50, 
                                 start = 1, 
                                 end = max(edges$terminus), 
                                 aggregate.dur = 50, 
                                 rule='any'),
                  verbose = T)
# plot(network, displaylabels=TRUE)

timePrism(dNetwork,at=c(1,10,20),
          displaylabels=TRUE,planes = TRUE,
          label.cex=0.5)

timeline(dNetwork)

# plot(dNetwork,
#      edge.label=(dNetwork %e% 'tokenId.active'),
#      edge.label.col='blue') 

render.d3movie(dNetwork, 
               output.mode = 'htmlWidget',
               vertex.tooltip = paste("<b>Address:</b>", (network %v% 'label')),
               edge.tooltip = paste("<b>TokenId:</b>", (network %e% 'tokenId')),
               # displaylabels = TRUE,
               launchBrowser = T,
               main='Ethereum transactions of Weird Whales NFTs',
               # edge.col = function(slice){slice%e%'tokenId.active'},
               # edge.label = function(slice){slice%e%'tokenId.active'},
               usearrows = T)

```

# Conclusion

so...

