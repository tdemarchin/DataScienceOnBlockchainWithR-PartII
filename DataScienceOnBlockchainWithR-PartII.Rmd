---
title: "Data Science on Blockchain with R. Part II: Tracking CryptoPunk NFTs"
author: "By Thomas de Marchin (Senior Manager Statistics and Data Sciences at Pharmalex) and Milana Filatenkova (Manager Statistics and Data Sciences at Pharmalex)"
date: "XXX2021"
output: html_document
---

```{r setup, include=FALSE}
rm(list=ls())
knitr::opts_chunk$set(echo = TRUE, warning=FALSE, message=FALSE)
```

![CryptoPunks are the earliest versions of NFTs (www.larvalabs.com/cryptopunks). Image modified from https://commons.wikimedia.org/wiki/File:Cryptopunks.png.](figures/myCruptoPunks.png)

# Introduction

```{r}
# First, let's load a few useful packages
library(tidyverse)
library(httr)
library(jsonlite)
library(plotly)
library(patchwork)
library(cowplot)
library(ggnetwork)
library(networkDynamic)
library(ndtv)
```


How to make the blockchain more transparent? Money laundering,...

Code of the CryptoPunk contract: https://etherscan.io/address/0xb47e3cd837ddf8e4c57f05d70ab865de6e193bbb#code

Structure of the event:
    event Assign(address indexed to, uint256 punkIndex);
    event Transfer(address indexed from, address indexed to, uint256 value);
    event PunkTransfer(address indexed from, address indexed to, uint256 punkIndex);
    event PunkOffered(uint indexed punkIndex, uint minValue, address indexed toAddress);
    event PunkBidEntered(uint indexed punkIndex, uint value, address indexed fromAddress);
    event PunkBidWithdrawn(uint indexed punkIndex, uint value, address indexed fromAddress);
    event PunkBought(uint indexed punkIndex, uint value, address indexed fromAddress, address indexed toAddress);

Interesting events:



topics[0] is the hash of the event signature
 
PunkBought(punkIndex, msg.value, seller, msg.sender);
  topic0 = 0x58e5d5a525e3b40bc15abaa38b5882678db1ee68befd2f60bafe3a7fd06db9e3

// Transfer ownership of a punk to another user without requiring payment
PunkTransfer(msg.sender, to, punkIndex)
  topic0 = 0x05af636b70da6819000c49f85b21fa82081c632069bb626f30932034099107d8


# Tracking the CryptoPunk NFTs


```{r}
# # EtherScan requires a token, have a look at their website. Please, use your own token!
# EtherScanAPIToken <- "UJP16VCE9D29XFAA86RWADATJ5K4PBSYD9" 
# 
# resEtherScanPunkBought <- GET("https://api.etherscan.io/api",
#           query = list(module="logs", 
#                        action="getLogs", 
#                        # fromBlock="0",
#                        # toBlock="latest",
#                        address="0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB",
#                        topic0="0x58e5d5a525e3b40bc15abaa38b5882678db1ee68befd2f60bafe3a7fd06db9e3", # Hash of the PunkBought event
#                        sort="desc",
#                        apikey=EtherScanAPIToken)) 
# 
# dataEtherScanPunkBought <- fromJSON(rawToChar(resEtherScanPunkBought$content), flatten=TRUE)$result
# 
# dataEtherScanPunkBought2 <- dataEtherScanPunkBought %>% 
#   mutate(timeStamp=as.POSIXct(as.numeric(timeStamp), origin="1970-01-01")) %>%
#   unnest_wider(topics) %>% # reshape the topic column (list) to get a column for each topics
#   rename(`eventHash`=`...1`, #rename as original naming is not very practical
#          `punkIndex`=`...2`,
#          `fromAddress`=`...3`,
#          `toAddress`=`...4`,
#          `value`=`data`) %>%
#   mutate(value=as.numeric(value) / 10^18, # convert first Hexadecimal to numeric and then Wei to ETH
#          punkIndex=as.numeric(punkIndex), # convert Hexadecmal to numeric
#          fromAddress=paste0("0x", str_sub(fromAddress,-40,-1)), # reshape the adress format to something more conventional
#          toAddress=paste0("0x", str_sub(toAddress,-40,-1)))

# It is possible to transfer without payement but let's first focus on the real sales.
# resEtherScanPunkTransfer <- GET("https://api.etherscan.io/api",
#           query = list(module="logs", 
#                        action="getLogs", 
#                        fromBlock="0",
#                        toBlock="latest",
#                        address="0xb47e3cd837dDF8e4c57F05d70Ab865de6e193BBB",
#                        topic0="0x05af636b70da6819000c49f85b21fa82081c632069bb626f30932034099107d8",
#                        sort="desc",
#                        apikey=EtherScanAPIToken)) 
# 
# dataEtherScanPunkTransfer <- fromJSON(rawToChar(resEtherScanPunkTransfer$content), flatten=TRUE)$result


```

# Tracking the Weird Whales

The Weird Whales project is a collection of 3350 whales which have been programmatically generated from an ocean of combinations, each with unique characteristics and different traits: https://weirdwhalesnft.com/. This was created by 12-year-old programmer named Benyamin Ahmed. The 3,350 computer-generated “Weird Whales” almost instantly sold out based on the heartwarming story and Benyamin made more than 150,000\$. Whales were initially sold at approximately 60\$ but since then, there price has been multiplied by 100...  

## Downloading the NFTs

```{r}
# # Retrieve sold NFTs 
 sequenceTokenIds <- seq(1, 3350, by=50)
# dataOpenSea <- list()
# 
# # The API is limited to 50 observation per call. We have to use a loop to retrieve the 3350 items of the Weird whale collection.
# for(i in 1:length(sequenceTokenIds)){
#   print(sequenceTokenIds[i])
# 
#   # These 2 steps are necessary to build the "token_ids" part of the URL.
#   # We can't use the GET "query" option as we need to push an array of token_ids and there is no easy way to do that with that option.
#   tokenIds <- seq(from=sequenceTokenIds[i], to=sequenceTokenIds[i]+49)
#   requestTokenIds <- paste0("token_ids=", tokenIds, collapse="&")
#   request <- paste0("https://api.opensea.io/api/v1/assets?limit=50&asset_contract_address=0x96ed81c7f4406eff359e27bff6325dc3c9e042bd&", requestTokenIds) #build the request URL
#   resOpenSea <- GET(request)
#   dataOpenSea[[i]] <- fromJSON(rawToChar(resOpenSea$content), flatten=TRUE)[[1]]
# }
# 
# dataOpenSea <- bind_rows(dataOpenSea) %>% #combine the list in a dataframe
#   mutate(token_id = as.numeric(token_id)) %>%
#   arrange(token_id)

# # Download the pictures
# for(i in 1:nrow(dataOpenSea)){
#   print(paste("Downloading image:", i))
#   download.file(url = dataOpenSea$image_preview_url[i], #let's just download the preview, their size is small and resolution is fine for our needs
#                 destfile = paste0("figures/WeirdWhales/", 
#                                   dataOpenSea$token_id[i], '.png'), 
#                 mode = 'wb',
#                 quiet = TRUE)
# }


samples <- sample(sequenceTokenIds, size=8)
p1 <- ggdraw() + draw_image(paste0("figures/WeirdWhales/", samples[1], ".png"), scale = 0.9)
p2 <- ggdraw() + draw_image(paste0("figures/WeirdWhales/", samples[2], ".png"), scale = 0.9)
p3 <- ggdraw() + draw_image(paste0("figures/WeirdWhales/", samples[3], ".png"), scale = 0.9)
p4 <- ggdraw() + draw_image(paste0("figures/WeirdWhales/", samples[4], ".png"), scale = 0.9)
p5 <- ggdraw() + draw_image(paste0("figures/WeirdWhales/", samples[5], ".png"), scale = 0.9)
p6 <- ggdraw() + draw_image(paste0("figures/WeirdWhales/", samples[6], ".png"), scale = 0.9)
p7 <- ggdraw() + draw_image(paste0("figures/WeirdWhales/", samples[7], ".png"), scale = 0.9)
p8 <- ggdraw() + draw_image(paste0("figures/WeirdWhales/", samples[8], ".png"), scale = 0.9)
p1 + p2 + p3 + p4 + p5 +p6 + p7 + p8 + plot_layout(nrow = 2)
```


Here is an example of a Weird Whale NFT transaction: https://etherscan.io/tx/0x2b21165a60abe3dfdc94d03fd9daa0671dc9b982e8b7fdf6342ed28967c15cfd#eventlog


```{r}
# EtherScan requires a token, have a look at their website. Please, use your own token!
EtherScanAPIToken <- "UJP16VCE9D29XFAA86RWADATJ5K4PBSYD9" 

dataWeirdWhaleTransfer <- list()
continue <- 1
i <- 0

while(continue == 1){ # We will run trough the blocks (from the earliest mentioning Weird whales to the latest). As soon ...
i <- i + 1
print(i)
if(i == 1){fromBlock = 12857046} #first block mentioning Weird Whale contract

# Get the transfer events from the Weird Whale contract
resWeirdWhaleTransfer <- GET("https://api.etherscan.io/api",
          query = list(module="logs", 
                       action="getLogs", 
                       fromBlock=fromBlock, #first block mentioning Weird Whale contract
                       toBlock="latest",
                       address="0x96ed81c7f4406eff359e27bff6325dc3c9e042bd", # address of the Weird Whale contract
                       topic0="0xddf252ad1be2c89b69c2b068fc378daa952ba7f163c4a11628f55a4df523b3ef", # hash of the Transfer event
                       apikey=EtherScanAPIToken)) 

dataWeirdWhaleTransfer[[i]] <- fromJSON(rawToChar(resWeirdWhaleTransfer$content), flatten=TRUE)$result %>%
  select(-gasPrice, -gasUsed, -logIndex)

if(i > 1){
if(all_equal(dataWeirdWhaleTransfer[[i]], dataWeirdWhaleTransfer[[i-1]]) == TRUE){continue <- 0}  
} #at some point, we always download the same last transaction

fromBlock <- max(as.numeric(dataWeirdWhaleTransfer[[i]]$blockNumber)) # increase the block to start looking at for the next iteration
}

dataWeirdWhaleTransfer <- bind_rows(dataWeirdWhaleTransfer) %>% #coerce list to dataframe
  distinct() # eliminate potential duplicated rows due to our trick to avoid the 1000 transaction limitation from EtherScan

# Do a bit of data management
dataWeirdWhaleTransfer <- dataWeirdWhaleTransfer %>% 
  mutate(timeStamp=as.POSIXct(as.numeric(timeStamp), origin="1970-01-01")) %>%
  mutate(topics = purrr::map(topics, setNames, c("eventHash","fromAddress","toAddress","tokenId"))) %>% # it is important to set the names otherwise unnest_wider will print many warning messages.
  unnest_wider(topics) %>% # reshape the topic column (list) to get a column for each topic. 
  mutate(tokenId=as.character(as.numeric(tokenId)), # convert Hexadecmal to numeric
         blockNumber=as.numeric(blockNumber),
         fromAddress=paste0("0x", str_sub(fromAddress,-40,-1)), # reshape the adress format to something more conventional
         toAddress=paste0("0x", str_sub(toAddress,-40,-1))) %>%
  mutate(tokenId = factor(tokenId, levels=as.character(sort(unique(as.numeric(tokenId))))))

# Summary statistics
summary(dataWeirdWhaleTransfer$timeStamp)

dataWeirdWhaleTransfer %>%
  summarise(`Number of transactions` = n(),
            `Unique token` = length(unique(tokenId)),
            `Unique senders` = length(unique(fromAddress)),
            `Unique receivers` = length(unique(toAddress)),
            `Date range` = paste(min(timeStamp), max(timeStamp), sep=" - "),
            `Days` = max(timeStamp) - min(timeStamp)
            ) 

summarySender <- dataWeirdWhaleTransfer %>%
  group_by(fromAddress) %>%
  summarise(`Number of transactions`=n()) %>%
  rename(`Sender address` = fromAddress) %>%
  arrange(desc(`Number of transactions`))
```

1) Faire un Graph du prix des transactions en fonction du temps. (genre barplot - histogram)

We have data from
```{r}
tokenIdFilter <- dataWeirdWhaleTransfer %>%
  group_by(tokenId) %>%
  summarise(n = n()) %>%
  filter(n>3)

dataWeirdWhaleTransferFiltered <- dataWeirdWhaleTransfer %>%
  filter(tokenId %in% tokenIdFilter$tokenId) %>%
  droplevels()

# pScatterWeirdWhaleTransfer <- ggplot(aes(x=timeStamp, y=tokenId, group=tokenId, text=tokenId), data = dataWeirdWhaleTransferFiltered) +
#   geom_point() + geom_line()
# pScatterWeirdWhaleTransfer <- ggplotly(pScatterWeirdWhaleTransfer, tooltip = "text")

#https://plotly-r.com/supplying-custom-data.html/
#Encode the images directly in the object 
dataWeirdWhaleTransferFiltered$image <- purrr::map_chr(
  dataWeirdWhaleTransferFiltered$tokenId, ~ base64enc::dataURI(file = sprintf("figures/WeirdWhales/%s.png", .x))
)

# create the plotly with the embedded NFT image
plot_ly(type = 'scatter',
        x = ~timeStamp, 
            y = ~tokenId, 
            customdata = ~image, 
            text = ~ paste0("Token ID: ", tokenId), 
            hoverinfo = 'text',
            mode = "lines+markers", 
            split = ~tokenId,
            data = dataWeirdWhaleTransferFiltered) %>%
  htmlwidgets::onRender(readLines("js/tooltip-image.js")) # this script allows to embed the NFT image when hoovering a point
```


Here we outline a process to create a set of large databases so we have local access to image data and trade data of the cryptopunks,

Network graph: 


2) Faire un graph avec ggnetwork puis montrer qu'on peut l'animer.

A vertex (or node) of a graph is one of the objects that are connected together. The connections between the vertices are called edges (or links). 

```{r, fig}
# senderFilter <- summarySender %>%
#   filter(`Number of transactions`>20)
# 
# dataWeirdWhaleTransferFiltered <- dataWeirdWhaleTransfer %>%
#   filter(fromAddress %in% senderFilter$`Sender address`) %>%
#   droplevels()

tokenIdFilter <- dataWeirdWhaleTransfer %>%
  group_by(tokenId) %>%
  summarise(n = n()) %>%
  filter(n>7)

dataWeirdWhaleTransferFiltered <- dataWeirdWhaleTransfer %>%
  filter(tokenId %in% tokenIdFilter$tokenId) %>%
  # filter(fromAddress != "0x0000000000000000000000000000000000000000") %>% #let's remove the minting as it leads to 
  droplevels()


dataWeirdWhaleTransferFiltered <- dataWeirdWhaleTransferFiltered %>%
  mutate(timeStampHour = round.POSIXt(timeStamp, "hour")) %>% # The time resolution is seconds. That is nice but it leads to a lot of computation (frames) for our network. Let's round to hours.
  mutate(timeStampHourNumeric = as.numeric(timeStampHour)/3600) %>%
  mutate(timeStampHourNumeric = timeStampHourNumeric-min(timeStampHourNumeric))  

# vertices is a listing of all the addresses involved in the transactions   
vertices <- tibble(label = factor(unique(c(dataWeirdWhaleTransferFiltered$fromAddress,
                                           dataWeirdWhaleTransferFiltered$toAddress))))  %>%
  rowid_to_column("id") # instead of using the addresses to visually identify the vertices, we will use shorter ID numbers 


# edges is a listing of the transactions
edges <- dataWeirdWhaleTransferFiltered %>%
  left_join(vertices, by = c("fromAddress" = "label")) %>% 
  rename(from = id) %>%
  left_join(vertices, by = c("toAddress" = "label")) %>%
  rename(to = id) 

# This will be useful to create a temporal dynamic network later on. Edges will appear at `onset` and disappear at `terminus.`

edges <- edges %>%
  rename(onset = timeStampHourNumeric) %>% 
  mutate(terminus = max(onset), #  
         tokenId = as.character(tokenId)) %>%
  select(from, to, tokenId, onset, terminus) 

# For the temporal dynamic network, we can also make the vertices appear at at `onset` and disappear at `terminus.`

firstAppearanceVertices <- rbind(data.frame(id=edges$from, onset=edges$onset),
                              data.frame(id=edges$to, onset=edges$onset)) %>%
  group_by(id) %>%
  summarise(onset = min(onset))

lastAppearanceVertices <- rbind(data.frame(id=edges$from, terminus=edges$terminus),
                              data.frame(id=edges$to, terminus=edges$terminus)) %>%
  group_by(id) %>%
  summarise(terminus = max(terminus))

vertices <- vertices %>%
  left_join(firstAppearanceVertices) %>%
  left_join(lastAppearanceVertices)


# mieux maitriser les dataframes
network <- network(edges[,c("onset","terminus","from","to")],  
                         vertex.attr = vertices[,c("id", "onset", "terminus")], 
                   matrix.type="edgelist", 
                loops=T, 
                multiple=T, 
                ignore.eval = F)

# network %v% "label" <- vertices[,"label"]
# network %e% "tokenId" <- edges[,"tokenId"]

ggNetwork <- ggnetwork(network)

ggplot(ggNetwork, aes(x = x, y = y, xend = xend, yend = yend)) +
  geom_edges(color = "black") +
  geom_nodes(color = "black", size = 8) +
  geom_nodetext(aes(label = label),
                fontface = "bold") +
  theme_blank()
# 
# #* simple networks ====================================================================
# simple_edge_df <- data.frame(
#   from = c("b", "c", "c", "d", "a"),
#   to = c("a", "b", "a", "a", "b"),
#   weight = c(1, 1, 2, 2, 3),
#   stringsAsFactors = FALSE
# )
# simple_edge_df
# 
# as.network(simple_edge_df)
# 
# # simple networks with vertices =======================================================
# simple_vertex_df <- data.frame(
#   name = letters[1:5],
#   residence = c("urban", "rural", "suburban", "suburban", "rural"),
#   stringsAsFactors = FALSE
# )
# simple_vertex_df
# 

# network <- networkDynamic(edge.spells = data.frame(edges[,c("onset","terminus","from","to")]),
# vertex.spells = data.frame(vertices[,c("onset","terminus","id")]))

# activate dynamic elements for the tooltips
network <- activate.vertex.attribute(network, 'label', data.frame(nodes[,c(2)]))
network <- activate.edge.attribute(network, 'tokenId', data.frame(edges[,c(3)]))

# plot(network)
compute.animation(network, 
                  # animation.mode='MDSJ',
                  animation.mode='Graphviz', # Graphviz is the best
                  slice.par=list(interval = 50, 
                                 start = 1, 
                                 end = max(edges$terminus), 
                                 aggregate.dur = 50, 
                                 rule='any'),
                  verbose = T)
# plot(network, displaylabels=TRUE)

timePrism(network,at=c(1,10,20),
          displaylabels=TRUE,planes = TRUE,
          label.cex=0.5)

timeline(network)

plot(network,
     edge.label=(network %e% 'tokenId.active'),
     edge.label.col='blue') 

render.d3movie(network, 
               output.mode = 'htmlWidget',
               vertex.tooltip = paste("<b>Address:</b>", (network %v% 'label.active')),
               # edge.tooltip = paste("<b>TokenId:</b>", (network %e% 'tokenId.active')),
               # displaylabels = TRUE,
               launchBrowser = T,
               main='Ethereum transactions of Weird Whales NFTs',
               edge.col = function(slice){slice%e%'tokenId.active'},
               edge.label = function(slice){slice%e%'tokenId.active'},
               usearrows = T)



#To do: filter token involved in more than X transactions instead
```




```{r}
# # Get the OrderMatch events from the Weird Whale contract
# resOpenSeaOrderMatch <- GET("https://api.etherscan.io/api",
#           query = list(module="logs", 
#                        action="getLogs", 
#                        fromBlock="12859414", # before that block, transfer event was for minting
#                        toBlock="latest",
#                        address="0x7be8076f4ea4a4ad08075c2508e481d6c946d12b", # adress of the Open Sea contract
#                        topic0="0xc4109843e0b7d514e4c093114b863f8e7d8d9a458c372cd51bfe526b588006c9", # hash of the OrderMatch event
#                        sort="desc",
#                        apikey=EtherScanAPIToken)) 
# 
# dataOpenSeaOrderMatch <- fromJSON(rawToChar(resOpenSeaOrderMatch$content), flatten=TRUE)$result %>%
#   select(-gasPrice, -gasUsed, -logIndex)
# 
# dataOpenSeaOrderMatch <- dataOpenSeaOrderMatch %>% 
#   mutate(timeStamp=as.POSIXct(as.numeric(timeStamp), origin="1970-01-01")) %>%
#   unnest_wider(topics) %>% # reshape the topic column (list) to get a column for each topics
#   rename(`eventHash`=`...1`, #rename as original naming is not very practical
#          `fromAddress`=`...2`,
#          `toAddress`=`...3`,
#          `metadata`=`...4`,
#          `data`=`data`) %>%
#   mutate(blockNumber=as.numeric(blockNumber),
#          fromAddress=paste0("0x", str_sub(fromAddress,-40,-1)), # reshape the adress format to something more conventional
#          toAddress=paste0("0x", str_sub(toAddress,-40,-1)))
# 
# a <- left_join(dataWeirdWhaleTransfer, dataOpenSeaOrderMatch, by="transactionHash")
# 
# 
# hex_string <- "0x00000000000000000000000000000000000000000000000000000000000000006cb5c489ae0fd5b83bc8ac37481e9e76e1d0cf763e3f03daa06ad581ef74a5240000000000000000000000000000000000000000000000000058d15e17628000"
# library(stringr)
# str_sub(hex_string, 64, 0)
# 
# library(wkb)
# hex_raw <- wkb::hex2raw(hex_string)
# text <- rawToChar(as.raw(strtoi(hex_raw, 16L)))
# # now i can get the rensaction price by merging with the OrderMatch event from the address 0x7be8076f4ea4a4ad08075c2508e481d6c946d12b https://etherscan.io/tx/0x2b21165a60abe3dfdc94d03fd9daa0671dc9b982e8b7fdf6342ed28967c15cfd#eventlog